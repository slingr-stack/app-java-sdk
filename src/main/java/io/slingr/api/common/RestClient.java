package io.slingr.api.common;

import com.idea2.endpoints.ExchangeParameter;
import com.idea2.exceptions.NotFoundException;
import com.idea2.exceptions.WsExceptionFactory;
import com.idea2.utils.Json;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.glassfish.jersey.client.ClientProperties;
import org.glassfish.jersey.client.authentication.HttpAuthenticationFeature;
import org.glassfish.jersey.media.multipart.Boundary;
import org.glassfish.jersey.media.multipart.MultiPart;

import javax.ws.rs.ProcessingException;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.client.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;

/**
 * <p>REST client to help to consume external services
 * <p/>
 * <p>Created by lefunes on 14/05/15.
 */
public abstract class RestClient {
    private static final Logger logger = Logger.getLogger(RestClient.class);

    private static final int MAX_RETRIES = 12;

    private Client client;
    private WebTarget apiTarget;

    private final Map<String, Object> apiHeaders = new HashMap<>();
    // max number of retries during service call
    private Integer retries;
    private Integer connectionTimeout = 5 * 1000; // 5 seconds by default
    private Integer readTimeout = 60 * 1000; // 60 seconds by default

    private boolean silenceLogger = false;
    private boolean convertContentToString = true;

    /**
     * Constructs a RestClient with the given base URI
     *
     * @param apiUri base URI to build the requests to the API.
     */
    public RestClient(String apiUri) throws RestException {
        this(apiUri, false);
    }

    /**
     * Constructs a secure RestClient with the given base URI
     *
     * @param apiUri base URI to build the requests to the API.
     * @param allowSelfSignedCertificate if it is allowed to access HTTPS sites with self signed certificates
     */
    public RestClient(String apiUri, boolean allowSelfSignedCertificate) throws RestException {
        if (StringUtils.isBlank(apiUri)) {
            throw new RestException(RestErrorType.ARGUMENT_EXCEPTION, String.format("Empty URI API parameter [%s]", apiUri));
        }
        if (allowSelfSignedCertificate) {
            RestClientFactory.RestClientOptions options = new RestClientFactory.RestClientOptions();
            options.allowSelfSignedCertificate = true;
            this.client = RestClientFactory.configureClient(options);
        } else {
            this.client = RestClientFactory.configureClient();
        }
        this.apiTarget = client.target(apiUri);
    }

    public RestClient(String apiUri, RestClientFactory.RestClientOptions options) {
        if (StringUtils.isBlank(apiUri)) {
            throw new RestException(RestErrorType.ARGUMENT_EXCEPTION, String.format("Empty URI API parameter [%s]", apiUri));
        }
        this.client = RestClientFactory.configureClient(options);
        this.apiTarget = client.target(apiUri);
    }

    /**
     * Sets true if you want to silence the logs generated by the client. The log will be showed in TRACE when this
     * function is enabled.
     */
    public void setSilenceLogger(boolean silenceLogger) {
        this.silenceLogger = silenceLogger;
    }

    /**
     * Sets true if you want to convert the content to string before to send (true by default)
     */
    public void setConvertContentToString(boolean convertContentToString) {
        this.convertContentToString = convertContentToString;
    }

    protected WebTarget getApiTarget() {
        return apiTarget;
    }

    /**
     * Configures a parameter that will be sent in all requests. For example a token is a typical
     * case where you need this.
     */
    protected void setupDefaultParam(String name, String value) {
        this.apiTarget = this.apiTarget.queryParam(name, value);
    }

    /**
     * Configures a path to the base target API
     */
    protected void setPath(String path) {
        // add path
        if(StringUtils.isNotBlank(path)) {
            this.apiTarget = this.apiTarget.path(path);
        }
    }

    /**
     * Configures a header that will be sent in all requests. For example a token is a typical
     * case where you need this.
     */
    protected void setupDefaultHeader(String name, Object value) {
        this.apiHeaders.put(name, value);
    }

    /**
     * Perform a GET request with the target information
     */
    protected Json get(WebTarget target) throws RestException {
        return execute(RestMethod.GET, target);
    }

    /**
     * Configures basic authentication in the client so calls will use it.
     *
     * @param username the username to authenticate
     * @param password the password of the user
     */
    public void setupBasicAuthentication(String username, String password) {
        HttpAuthenticationFeature feature = HttpAuthenticationFeature.basic(username, password);
        apiTarget = apiTarget.register(feature);
    }


    /**
     * Configures digest authentication in the client so calls will use it.
     *
     * @param username the username to authenticate
     * @param password the password of the user
     */
    public void setupDigestAuthentication(String username, String password) {
        HttpAuthenticationFeature digestAuthFeature = HttpAuthenticationFeature.digest(username, password);
        apiTarget = apiTarget.register(digestAuthFeature);
    }

    /**
     * Perform a POST request with the target information and JSON content
     */
    protected Json post(WebTarget target) throws RestException {
        return execute(RestMethod.POST, target);
    }

    /**
     * Perform a POST request with the target information and JSON content
     */
    protected Json post(WebTarget target, Json content) throws RestException {
        return execute(RestMethod.POST, target, content);
    }

    /**
     * Perform a POST request with the target information and multi-part content
     */
    protected Json post(WebTarget target, MultiPart content) throws RestException {
        return execute(RestMethod.POST, target, content);
    }

    /**
     * Perform a PUT request with the target information (json)
     */
    protected Json put(WebTarget target) throws RestException {
        return execute(RestMethod.PUT, target);
    }

    /**
     * Perform a PUT request with the target information (json)
     */
    protected Json put(WebTarget target, Json content) throws RestException {
        return execute(RestMethod.PUT, target, content);
    }

    /**
     * Perform a PUT request with the target information and multi-part content
     */
    protected Json put(WebTarget target, MultiPart content) throws RestException {
        return execute(RestMethod.PUT, target, content);
    }

    /**
     * Perform a PUT request with the target information (json)
     */
    protected Json patch(WebTarget target) throws RestException {
        return execute(RestMethod.PATCH, target);
    }

    /**
     * Perform a PUT request with the target information (json)
     */
    protected Json patch(WebTarget target, Json content) throws RestException {
        return execute(RestMethod.PATCH, target, content);
    }

    /**
     * Perform a DELETE request with the target information
     */
    protected Json delete(WebTarget target) throws RestException {
        return execute(RestMethod.DELETE, target);
    }

    /**
     * Perform a DELETE request with the target information
     */
    protected Json delete(WebTarget target, Json content) throws RestException {
        return execute(RestMethod.DELETE, target, content);
    }

    /**
     * Perform a HEAD request with the target information
     */
    protected Json head(WebTarget target) throws RestException {
        return execute(RestMethod.HEAD, target);
    }

    /**
     * Perform a OPTIONS request with the target information
     */
    protected Json options(WebTarget target) throws RestException {
        return execute(RestMethod.OPTIONS, target);
    }

    /**
     * Perform the specified request in the method with the target information
     */
    protected Json execute(RestMethod method, WebTarget target) throws RestException {
        return execute(method, target, null);
    }

    /**
     * Perform the specified request in the method with the target information
     */
    protected Json execute(RestMethod method, WebTarget target, Object content) throws RestException {
        return execute(method, (target != null ? target : apiTarget), apiHeaders, content, retries, connectionTimeout, readTimeout);
    }

    /**
     * Perform the specified request in the method with the target information
     */
    protected Json execute(RestMethod method, WebTarget target, Object content, Map<String, Object> additionalHeaders) throws RestException {
        Map<String, Object> mixedHeaders = new HashMap<>();
        if (apiHeaders != null) {
            mixedHeaders.putAll(apiHeaders);
        }
        if (additionalHeaders != null) {
            mixedHeaders.putAll(additionalHeaders);
        }
        return execute(method, (target != null ? target : apiTarget), mixedHeaders, content, retries, connectionTimeout, readTimeout);
    }

    public Integer getRetries() {
        return retries;
    }

    public void setRetries(Integer retries) {
        if (retries != null && retries >= 0) {
            this.retries = retries;
        } else {
            this.retries = null;
        }
    }

    public Integer getReadTimeout() {
        return readTimeout;
    }

    public void setReadTimeout(Integer readTimeout) {
        if (readTimeout != null && readTimeout >= 0) {
            this.readTimeout = readTimeout;
        } else {
            this.readTimeout = null;
        }
    }

    public Integer getConnectionTimeout() {
        return connectionTimeout;
    }

    public void setConnectionTimeout(Integer connectionTimeout) {
        if (connectionTimeout != null && connectionTimeout >= 0) {
            this.connectionTimeout = connectionTimeout;
        } else {
            this.connectionTimeout = null;
        }
    }

    /**
     * Perform the specified request in the method with the target information and content
     */
    private Json execute(RestMethod method, WebTarget target, Map<String, Object> apiHeaders, Object content, Integer retries, Integer connectionTimeout, Integer readTimeout) throws RestException {
        if (target == null) {
            throw new PermanentRestException(RestErrorType.ARGUMENT_EXCEPTION, "Invalid web and API target.");
        }
        if (content == null) {
            content = Json.map();
        }

        Entity postData = null;
        if (content instanceof Json) {
            if (apiHeaders.containsKey("Content-Type")) {
                // in this case need to override content type
                postData = Entity.entity(content.toString(), (String) apiHeaders.get("Content-Type"));
            } else {
                if(convertContentToString) {
                    postData = Entity.json(content.toString());
                } else {
                    postData = Entity.json(((Json) content).toObject());
                }
            }
        } else if (content instanceof MultiPart) {
            MediaType contentType = MediaType.MULTIPART_FORM_DATA_TYPE;
            contentType = Boundary.addBoundary(contentType);
            postData = Entity.entity(content, contentType);
        }

        final Invocation.Builder invocationBuilder = target.request();
        invocationBuilder.accept(MediaType.APPLICATION_JSON_TYPE);
        if (apiHeaders != null) {
            apiHeaders.forEach(invocationBuilder::header);
        }
        if (connectionTimeout != null) {
            invocationBuilder.property(ClientProperties.CONNECT_TIMEOUT, connectionTimeout);
        }
        if (readTimeout != null) {
            invocationBuilder.property(ClientProperties.READ_TIMEOUT, readTimeout);
        }

        String stringResponse = null;
        final String uri = target.getUri().toString();
        int retryCount = 0;

        logInfo(decorateLog("Executing method [%s %s]", method.name(), uri));
        if (logger.isTraceEnabled()) {
            try {
                String sData = null;
                if (postData != null && postData.getEntity() != null) {
                    sData = postData.getEntity().toString();
                    if (StringUtils.isNotBlank(sData) && sData.length() > 7000) {
                        sData = sData.substring(0, 7000) + "...";
                    }
                }
                if (StringUtils.isBlank(sData)) {
                    sData = "-";
                }
                logTrace(decorateLog("Data sent to [%s %s]: %s", method.name(), uri, sData));
            } catch (Exception ex) {
                logTrace(decorateLog("Exception when generates trace of data to send"));
            }
        }

        boolean retry;
        boolean canRetry = true;
        int maxRetries = MAX_RETRIES;
        if (retries != null) {
            maxRetries = retries;
            if(maxRetries <= 0){
                canRetry = false;
            }
        }
        do {
            retry = false;
            try {
                stringResponse = executeOperation(method, postData, invocationBuilder);
            } catch (ResponseProcessingException rpe) {
                throw new PermanentRestException(RestErrorType.API_EXCEPTION, String.format("Error processing response [%s]: %s", rpe.getMessage(), rpe.getResponse() != null ? rpe.getResponse() : "-"), rpe);
            } catch (ProcessingException pe) {
                retryCount++;
                if (retryCount >= maxRetries) {
                    if(pe.getCause() instanceof IOException){
                        throw new PermanentRestException(RestErrorType.CLIENT_EXCEPTION, String.format("Error processing request [%s]", RestException.getProcessingExceptionMessage(pe)), pe);
                    } else {
                        throw new RetryableRestException(RestErrorType.API_EXCEPTION, String.format("Error processing request [%s]", pe.getMessage()), pe);
                    }
                } else if ((StringUtils.isNotBlank(pe.getMessage()) && pe.getMessage().contains("org.apache.http.NoHttpResponseException"))) {
                    if (pe.getMessage().contains("ConnectTimeoutException")) {
                        logInfo("No Http response error received", pe);
                        return null;
                    } else {
                        logWarn(decorateLog("Retry [%s] for request [%s %s]. Reason: [%s].", retryCount, method.name(), uri, pe.getMessage()));
                        retry = canRetry;
                        try {
                            Thread.sleep(retryCount * 1000);
                        } catch (InterruptedException e) {
                            // do nothing
                        }
                    }
                } else {
                    logWarn(decorateLog("Retry [%s] for request [%s %s]. Reason: [%s]", retryCount, method.name(), uri, pe.getMessage()));
                    retry = canRetry;
                    try {
                        Thread.sleep(retryCount * 1000);
                    } catch (InterruptedException e) {
                        // do nothing
                    }
                }
            } catch (WebApplicationException wae) {
                Response r = wae.getResponse();
                String details = null;
                if (r != null) {
                    try {
                        details = r.readEntity(String.class);
                    } catch (Exception e) {
                        // do nothing
                    }
                    if (StringUtils.isNotBlank(details)) {
                        final String sDetail = details.toLowerCase().trim();
                        if (!sDetail.startsWith("<html") && !sDetail.startsWith("<!doctype ")) {
                            try {
                                final Json jsonDetail = Json.parse(details);
                                if (jsonDetail != null && jsonDetail.contains(ExchangeParameter.DATA.getName()) && jsonDetail.json(ExchangeParameter.DATA).is(ExchangeParameter.EXCEPTION_FLAG)) {
                                    logInfo(decorateLog("Exception on endpoint from [%s %s]", method.name(), uri));
                                    if (logger.isTraceEnabled()) {
                                        if (details.length() > 7000) {
                                            logTrace(decorateLog("Response received from [%s %s]: %s...", method.name(), uri, details.substring(0, 7000)));
                                        } else {
                                            logTrace(decorateLog("Response received from [%s %s]: %s", method.name(), uri, details));
                                        }
                                    }
                                    return jsonDetail;
                                }
                            } catch (Exception nee) {
                                //do nothing
                            }
                            if (details.length() > 7000) {
                                logDebug(decorateLog("HTTP Status: [%s], Message: [%s], Content: %s...", r.getStatus(), wae.getMessage(), details.substring(0, 7000)));
                            } else {
                                logDebug(decorateLog("HTTP Status: [%s], Message: [%s], Content: %s", r.getStatus(), wae.getMessage(), details));
                            }
                        }
                    }
                }
                // these might be retryable status codes according to W3: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
                if (r != null && (r.getStatus() == 408 || r.getStatus() == 500 || r.getStatus() == 502 || r.getStatus() == 503 || r.getStatus() == 504)) {
                    retryCount++;
                    if (retryCount >= maxRetries) {
                        throw new RetryableRestException(RestErrorType.API_EXCEPTION, wae.getMessage(), wae);
                    } else {
                        logWarn(decorateLog("Retry [%s] for request [%s %s]. Reason: [%s]", retryCount, method.name(), uri, r.getStatus()));
                        retry = canRetry;
                        try {
                            Thread.sleep(retryCount * 1000);
                        } catch (InterruptedException e) {
                            // do nothing
                        }
                    }
                } else {
                    // add more information for bad request status code
                    Map<String, Object> errorDetails = null;
                    if (details != null) {
                        // try to parse messages
                        try {
                            final Json jsonDetail = Json.parse(details);
                            errorDetails = jsonDetail.toMap();
                        } catch (Exception e) {
                            // do nothing
                        }
                    }
                    throw new PermanentRestException(RestErrorType.API_EXCEPTION, wae.getMessage(), wae, errorDetails);
                }
            } catch (RestException e) {
                if (e.toString().contains("ConnectTimeoutException")) {
                    logInfo("No Http response error received", e);
                    return null;
                } else {
                    throw e;
                }
            } catch (Exception e) {
                // we assume this is an unhandled exception that is a programming error
                throw new PermanentRestException(RestErrorType.GENERIC_ERROR, e.getMessage(), e);
            }
        } while (retry);

        logInfo(decorateLog("Successful response from [%s %s]", method.name(), uri));
        if (stringResponse != null && logger.isTraceEnabled()) {
            if(stringResponse.length() > 7000){
                logTrace(decorateLog("Response received from [%s %s]: %s...", method.name(), uri, stringResponse.substring(0, 7000)));
            } else {
                logTrace(decorateLog("Response received from [%s %s]: %s", method.name(), uri, stringResponse));
            }
        }

        try {
            return Json.parse(stringResponse != null ? stringResponse : "{}");
        } catch (Exception ex) {
            throw new RestException(RestErrorType.CONVERSION_EXCEPTION, ex.getMessage(), ex);
        }
    }

    private static String executeOperation(RestMethod method, Entity postData, Invocation.Builder invocationBuilder) {
        String stringResponse = null;
        switch (method) {
            case POST:
                stringResponse = invocationBuilder.post(postData, String.class);
                break;
            case PUT:
                stringResponse = invocationBuilder.put(postData, String.class);
                break;
            case PATCH:
                stringResponse = invocationBuilder.method(RestMethod.PATCH.name(), postData, String.class);
                break;
            case DELETE:
                if (postData != null) {
                    stringResponse = invocationBuilder.method(RestMethod.DELETE.name(), postData, String.class);
                } else {
                    stringResponse = invocationBuilder.delete(String.class);
                }
                break;
            case HEAD:
                final Object response = invocationBuilder.head().getEntity();
                if (response instanceof InputStream) {
                    stringResponse = convertToString((InputStream) response);
                } else if (response != null) {
                    stringResponse = response.toString();
                }
                break;
            case OPTIONS:
                stringResponse = invocationBuilder.options(String.class);
                break;
            default:
                // GET by default
                stringResponse = invocationBuilder.get(String.class);
                break;
        }
        return stringResponse;
    }

    private static String convertToString(InputStream inputStream) {
        try {
            return IOUtils.toString(inputStream, StandardCharsets.UTF_8);
        } catch (IOException e) {
            logger.warn("Error parsing string from input stream", e);
            return null;
        }
    }

    public InputStream download(WebTarget target) {
        return download(target, false);
    }

    public InputStream download(WebTarget target, boolean throwException) {
        return download((target != null ? target : apiTarget), apiHeaders, throwException);
    }

    static InputStream download(WebTarget target, Map<String, Object> apiHeaders, boolean throwException) {
        final Invocation.Builder invocationBuilder = target.request();
        if (apiHeaders != null) {
            apiHeaders.forEach(invocationBuilder::header);
        }
        final Response res = invocationBuilder.get();
        if(throwException){
            if(res == null){
                throw WsExceptionFactory.getWsExceptionByStatus(400, "Exception when try to download file from application");
            }
            if(res.getStatus() == 404){
                throw new NotFoundException(res.readEntity(String.class));
            } else if(res.getStatus() >= 400){
                throw WsExceptionFactory.getWsExceptionByStatus(res.getStatus(), res.readEntity(String.class));
            }
        }
        return res.readEntity(InputStream.class);
    }

    protected void logTrace(String message) {
        logTrace(message, null);
    }

    protected void logTrace(String message, Throwable exception) {
        if(silenceLogger){
            log("TRACE", message, exception);
        } else {
            logger.trace(message, exception);
        }
    }

    protected void logDebug(String message) {
        logDebug(message, null);
    }

    protected void logDebug(String message, Throwable exception) {
        if(silenceLogger){
            log("DEBUG", message, exception);
        } else {
            logger.debug(message, exception);
        }
    }

    protected void logInfo(String message) {
        logInfo(message, null);
    }

    protected void logInfo(String message, Throwable exception) {
        if(silenceLogger){
            log("INFO", message, exception);
        } else {
            logger.info(message, exception);
        }
    }

    protected void logWarn(String message) {
        logWarn(message, null);
    }

    protected void logWarn(String message, Throwable exception) {
        if(silenceLogger){
            log("WARN", message, exception);
        } else {
            logger.warn(message, exception);
        }
    }

    protected void logError(String message) {
        logError(message, null);
    }

    protected void logError(String message, Throwable exception) {
        if(silenceLogger){
            log("ERROR", message, exception);
        } else {
            logger.error(message, exception);
        }
    }

    protected static String decorateLog(String msg, Object ... args) {
        return String.format(msg, args);
    }

    private static void log(String level, String message, Throwable exception) {
        logger.trace("["+level+"] "+message, exception);
    }

    /**
     * Check if need to enable https.
     */
    protected static boolean isSecureConnection(String apiUrl) {
        return apiUrl.startsWith("https");
    }
}
